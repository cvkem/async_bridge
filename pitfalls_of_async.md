# Pitfalls of asynchrous programming

I have been working on a project involving handling Parquet-files on S3. S3-operations are a good candidate for asynchronous programming, and Parquet is about big-data processing, so that is the type of stuff you like to store in a low cost storage like S3. For this project I used [AWS-rust-S3 library](https://crates.io/crates/aws-sdk-s3) (fully asynchronous) and the [reference implementation of Parquet](https://github.com/apache/arrow-rs/blob/master/parquet/README.md) which does have async support.


## Single-threaded code can halt easily
Soon I ran into issues as my tests seemed to fail. However, when calling the same code from a main program to inspect my code with a debugger everything seemed to be fine. This is one of the programmers nightmares as it means that the bug vanishes when you try to observe it, and re-appears when you look the other way. After studying some documentation I noticed that tokio tests are [ran on a single-threaded async engine when using the tag ](https://docs.rs/tokio/latest/tokio/attr.test.html) when using the default atrribute `#[tokio::test]` while the the [Tokio main macro](https://docs.rs/tokio/latest/tokio/attr.main.html) `#[tokio::main]` is multi-threaded by default. When changing my tests to use a multi-threaded async runtime via the attribute `#[tokio::test(flavor = "multi_thread")]` my tests did run without errors.

This does not explain yet why the code failed on a single-threaded async runtime. However, my assumption is that one of the libraries I used did execute some blocking code. As a result the program might halt because:
* it is waiting forever on another part of the program that can not continue.
* the async runtime might miss some timers or OS-events due to the fact that the thread that handles these events is blocked for too long.

## Future::executor::block_on is single threaded
Within my asynchronous program I also included some synchronous code. As this code did not take too much time, this should not cause any issues. However, I also needed to do some file operations in my synchronous, which are slow.  

## Rough materials follow below!!



## Getting back to an async context
Although


* future::block_on misunderstanding
* blocking on single-threaded engine
* preventing the start of multiple instances of the Tokio-runtime
    * When you do not know whether your main was asynchronous or a synchronous main (using a library for multiple usecases)
    * When you do not want the additional complexity of managing a single runtime and passing a handle to this runtime through your code-base to your different instances.
    * When you want lazy (just in time) initialization of the Async runtime, without having to think about the state management.
* ...
I did develop it when building a project to proces Parquet files and the standard libraries I needed did not give me the (documented) async support I needed. None of the solutions for [bridging to async code](https://tokio.rs/tokio/topics/bridging) as described by Tokio documentation did work for me, and I tripped over many wires (see [pitfalls of async](./pitfalls_of_async.md)), spend many our staring at the [tokio-console, a debugger for async code,](https://github.com/tokio-rs/console)  to try to understand why my program halted, but analyzing a program with 20+ tasks, while most tasks were generated by external libraries was not helpful to me.
In the end I developed the async_bridge to get me out of the mess, and it helped me a lot. I since then have used it in multiple related projects.


[block_on](https://docs.rs/futures/latest/futures/executor/fn.block_on.html)